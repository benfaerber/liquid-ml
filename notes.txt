Lex Liquid

Blocks:
Text
Statement {% %}
Expression {{ }}
Liquid
{% liquid

%}

Block List is a token grid
-----------------------------
Block Token Token Token Token
Block Token Token Token Token
Block Token Token Token Token
Block Token Token Token Token


What is a syntax tree?
Basic tree structure of nodes and leaves

type 'a tree =
| Leaf ()
| Node of 'a * 'a tree * 'a tree


Liquid block must compile the same as normal block

{% if x == y %}
  Hi there
{% endif %}

{%liquid
if x == y
  echo "Hi There"
endif
%}

{{ horse }}

Global (
  If ID(X) Eq ID(Y) Expression( Text(Hi There) ) Endif

  Expression(
    ID(horse)
  )
)

--------

{{ animal | capitalize | remove : "h" | slice: 0, 2 }}

The first param is the thing the filter is applied to
A filter has a name and a list of params
Operators are converted to function

Func (slice) (
  Func (remove) (
    Func (capitilize) (
      Value ( Var ("animal") )
    )
    Value ( String ("h") )
  )
  Value ( Number (0) )
  Value ( Number (2) )
)

if x == 1

Func (eq) (
  Value ( Var ("x") )
  Value ( Number (1))
)

How to build an Ast:
Just from token to token
If it is opener:
scan down while counting openers and closers
Once closer is found

Get open index and close index
Stuff that into algebreic dt
Run build rec.

Test condition:(x = 1) (build_ast tokens[open_index..close_index])

How to count else

if
  if
  end
else
  if
  else
  end
end

(if_count, end_count)
if = (1, 0)
  if = (2, 0)
    if = (3, 0)
    end = (3, 1)
  end = (3, 2)
else = If[1] is still open, this else belongs to that
  if = (2, 1)
  else = If[2]
  end = (2, 2)
end

For this to work I need to know scope

0: if - [0] open if on line 0
1:   if - [0 1] open if on line 1
2:   end - [0] most recent if was closed
3: else - [0] zero is the most recent open if, this else must belong to that
4:   if - [0 4]
5:   else - most recent if is 4, this belongs to that
6:   end - [0]
7: end - [] - Tally is empty, exit
8: echo "horseradish"
9: assign t = 1


length 100
22-57

100 - 57 = 43

22 + x

a == 1 and b > 2 or c <= 2 and d != 2

Parse:
Got: And (a == 2, b > 2)
Left: or c <= 2 and d != 2

Got: Or (C <= 2)
Left: and d != 2

Merge Or (
  And (a == 2, b > 2),
  C <= 2
)

Got: And d != 2
Left: Nothing

Merge And (
  Or (
    And (a == 2, b > 2),
    C <= 2
  )
  d != 2
)

And (Or (And (a == 2, b > 2), c <= 2) d != 2)
